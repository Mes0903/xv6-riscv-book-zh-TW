---
title: xv6 riscv book chapter 6：Locking
date: 2025-08-02
tag: 
- OS
- risc-v
category: 
- OS
- risc-v
---

# xv6 riscv book chapter 6：Locking

包括 xv6 的大多數 kernel，在執行時都會交錯進行多個活動。 造成交錯的其中一個原因是多核心的硬體：例如 xv6 的 RISC-V 支援多個獨立執行的 CPU。 這些 CPU 會共用實體 RAM，而 xv6 會善用這樣的特性來維護那些所有 CPU 都會讀寫的資料結構。 這種共用會產生一個問題，就是當某個 CPU 正在讀某個資料結構的同時，另一個 CPU 可能正好在修改它，甚至可能有多個 CPU 同時在修改同一筆資料

若沒有謹慎設計，這種平行存取很可能導致錯誤的結果，甚至破壞資料結構。 即便在單核心系統中，kernel 也可能在多個執行緒之間切換，使得它們的執行交錯進行。 最後，若某個裝置的 interrupt handler 與可被中斷的程式碼會修改同一份資料，而中斷剛好在不恰當的時機發生，則也可能會破壞資料。 並行（concurrency）這個詞就是指這種多條指令流因為多核心平行處理、執行緒切換，或中斷而產生交錯的情況

kernel 中充滿了會被並行存取的資料。 舉例來說，兩個 CPU 可能會同時呼叫 `kalloc`，導致它們同時從 free list 的開頭取出項目。 kernel 的設計者傾向允許大量的並行，因為這樣可以透過平行運作提升效能，也能讓系統的反應更快。 但也因此，設計者必須在這樣的並行條件下，確保系統的正確性。 要寫出正確的程式碼有很多方法，也有一些較簡單的方法。 在並行情況下確保正確性的策略，以及支援這些策略的抽象機制，統稱為並行控制（concurrency control）技術

xv6 依據不同情況使用多種並行控制技術，而實際上還有更多其他可能的做法。 本章會聚焦在一種被廣泛使用的技術：鎖（lock）。 lock 提供互斥（mutual exclusion），確保每次只有一個 CPU 能持有這個鎖。 如果程式設計者為每個共享資料加上一把對應的鎖，並且在使用這份資料時總是持有這把鎖，那麼每次就只有一個 CPU 能使用這筆資料。 我們稱這種情況為「lock 保護了這筆資料」。 儘管 lock 是一種易於理解的並行控制機制，但它的缺點是可能會限制效能，因為它會讓原本可以並行的操作變成序列化的執行

本章接下來將說明 xv6 為何需要鎖、xv6 是如何實作鎖的，以及它是如何使用這些鎖的
