---
title: xv6 riscv book chapter 4：Traps and system calls
date: 2025-07-31
tag: 
- OS
- risc-v
category: 
- OS
- risc-v
---

# xv6 riscv book chapter 4：Traps and system calls

有三種類型的事件會使 CPU 暫停正常的指令執行流程，並強制轉移控制權到一段專門處理該事件的程式碼。 第一種情況是系統呼叫，當使用者程式執行 `ecall` 指令時，會向核心提出對應的要求。 第二種情況是例外（exception）：某條指令（無論是來自使用者或核心）執行了非法操作，例如除以零或使用無效的虛擬位址。 第三種情況是裝置中斷（interrupt），如某個裝置發出訊號表示它需要被處理，例如硬碟完成某次讀寫請求的時候

本書將上述這些情況統稱為「trap」。 通常，發生 trap 時正在執行的程式碼之後需要能夠繼續執行，並且不應該察覺到任何特殊的事情發生了。 也就是說，我們通常希望 trap 是透明的； 這一點在處理裝置中斷時尤其重要，因為被中斷的程式碼通常不會預期到被打斷。 一般的處理流程是：trap 發生後控制權會轉移到核心； 核心會儲存暫存器與其他狀態，以便之後能夠恢復執行； 接著核心會執行對應的處理程式（例如系統呼叫的實作或裝置驅動程式）； 然後核心會還原先前儲存的狀態並從 trap 返回； 最後原本的程式碼會從中斷處繼續執行

xv6 在核心中處理所有的 trap，trap 並不會交由使用者程式處理。 將 trap 交由核心處理對於系統呼叫來說是理所當然的。 而將中斷交由核心處理也是合理的，因為有隔離的需求，所以只有核心能夠操作裝置，而且核心也提供了一個便利的機制，能夠讓多個行程共享裝置。 對於例外來說交由核心處理也合理，因為 xv6 對於所有來自使用者空間的例外都會以終止該程式作為回應

xv6 的 trap 處理流程分為四個階段：第一階段是 RISC-V CPU 執行的硬體動作； 第二階段是一些組合語言指令，用來為核心的 C 程式碼做準備； 第三階段是一個 C 函式，它決定該如何處理這個 trap； 第四階段則是執行對應的系統呼叫或裝置驅動服務常式

儘管這三種 trap 類型有不少共通性，理論上核心可以用一條通用的路徑來處理所有 trap，但實務上將其區分為兩種情況會更方便：來自使用者空間的 trap，與來自核心空間的 trap。 負責處理 trap 的核心程式碼（不論是組語或 C）通常被稱為「handler」； 而最先執行的那幾條 handler 指令通常以組合語言撰寫，有時會被稱為「vector」
