# Chapter 3：Page tables

頁表（Page Table）是作業系統用來為每個行程提供私有位址空間與記憶體的最常見的機制。 頁表決定了記憶體位址的含義，以及哪些物理記憶體區段可以被存取。 它們讓 xv6 能夠隔離不同行程的位址空間，並將它們多工使用在單一的物理記憶體上。 頁表之所以廣泛使用，是因為它們提供了一層間接性，使作業系統能夠進行許多「技巧」。 xv6 就使用了一些技巧：像是將相同的記憶體（例如 trampoline page）映射到多個位址空間中，並且用未映射的頁面來保護 kernel 與 user 的堆疊。 接下來的章節會說明 RISC-V 硬體所提供的頁表功能，以及 xv6 是如何使用這些功能的

## 3.1 Paging hardware

回顧一下，RISC-V 的指令（無論是使用者或核心）所操作的是虛擬位址。 機器的 RAM，也就是實體記憶體，則是以實體位址來索引。 RISC-V 的頁表硬體會將這兩種位址連接起來，將每個虛擬位址對應到一個實體位址來完成對映

xv6 運行在 Sv39 的 RISC-V 架構上，這代表 64 位元虛擬位址中，只有最低的 39 個位元會被使用，最上面的 25 個位元則不會被使用。 在 Sv39 的設定下，一個 RISC-V 頁表在邏輯上是一個包含 2<sup>27</sup>（134,217,728）個頁表項（PTE）的陣列。 每個 PTE 包含一個 44 位元的實體頁面編號（PPN）以及一些旗標

分頁硬體會使用 39 位元中最高的 27 位元作為索引查找頁表，找到對應的 PTE，然後組合成一個 56 位元的實體位址：其最高 44 位元來自 PTE 裡的 PPN，最低 12 位元則複製自原本的虛擬位址。 圖 3.1 顯示了這個流程，使用一個簡化為 PTE 陣列的邏輯頁表來呈現（更完整的結構請參考圖 3.2）。 頁表讓作業系統可以以 4096（2<sup>12</sup>）位元組對齊的區塊為單位，控制虛擬位址到實體位址的對應關係。 這種區塊就被稱作「頁面（page）」

![（Figure 3.1: RISC-V virtual and physical addresses, with a simplified logical page table.）](image/riscv_address.png)

在 Sv39 的 RISC-V 架構中，虛擬位址的最上面 25 個位元並不會參與轉換。 而在實體位址方面也預留了成長的空間：在 PTE 的格式中，實體頁面編號還可以再增加 10 個位元。 RISC-V 的設計者是根據技術的發展預測來選定這些數值的，2<sup>39</sup> 位元組等於 512GB，對於在 RISC-V 電腦上運行的應用程式來說應該已經足夠。 2<sup>56</sup> 則提供了足夠的實體記憶體空間，在可見的未來能容納許多 I/O 裝置與 RAM 模組。 如果未來還需要更多，RISC-V 的設計者也已定義了擁有 48 位元的虛擬位址空間的 Sv48<sup>[[1]](#1)</sup>

如圖 3.2 所示，RISC-V 的 CPU 會透過三個步驟將虛擬位址轉換為實體位址。 頁表在實體記憶體中會以三層的樹的形式儲存，這棵樹的根是一個 4096 位元組（一頁）的頁表，裡面包含 512 個 PTE，這些 PTE 內也各都儲存著下一層頁表的實體位址（其也是用一頁來儲存）。 而該頁表中的每個 PTE 所指向的頁表，其內會包含 512 個最底層的 PTE

分頁硬體會使用 27 位元中的最上面 9 位來在根頁表頁中選取一個 PTE，中間的 9 位元用來在下一層的頁表頁中選取一個 PTE，而最底下的 9 位元則用來選擇最終的 PTE（在 Sv48 的 RISC-V 中，頁表有四層，虛擬位址中的第 39 到 47 位會用來索引最頂層的頁表）

![（Figure 3.2: RISC-V address translation details.）](image/riscv_pagetable.png)

如果在位址轉換過程中所需的三個 PTE 中有任何一個不存在，分頁硬體就會產生一個「page-fault 例外」，並交由核心來處理這個例外（詳見第四章）

相較於圖 3.1 的單層設計，圖 3.2 所示的三層結構提供了一種更節省記憶體的方式來記錄 PTE。 在許多虛擬位址範圍根本沒有被對應的情況下，三層結構能夠直接省略整個頁表。 例如，如果一個應用程式只使用從位址 0 開始的幾個頁面，那麼第一層頁表內的第 1 到 511 的項目都會是無效的，核心不必耗費頁面來存這 511 個第二層頁表，也不需要分配這 511 個第二層頁表所對應到的底層頁表。 因此，在這個例子中，三層結構可以節省 511 頁的第二層頁表，以及 511×512 頁的底層頁表

雖然 CPU 會在執行 `load` 或 `store` 指令時，由硬體自動遍歷三層結構，但三層結構有個潛在缺點是：CPU 必須從記憶體中載入三個 PTE 才能完成虛擬位址到實體位址的轉換。 為了避免從實體記憶體載入 PTE 的開銷，RISC-V 的 CPU 會將 PTE 快取在一個稱為 Translation Look-aside Buffer（TLB）的結構中

每個 PTE 都包含一些旗標位元，用來告訴分頁硬體這個對應的虛擬位址允許被如何使用。 `PTE_V` 表示這個 PTE 是否存在：如果其沒被設置，則對該頁面的存取會引發例外。 `PTE_R` 決定指令能否讀取該頁。 `PTE_W` 決定能否寫入該頁。 `PTE_X` 決定 CPU 是否可以將該頁內容作為指令來執行。 `PTE_U` 決定user mode 下的指令是否可以存取該頁； 如果沒設置 `PTE_U`，則僅能在 supervisor mode 中使用該 PTE。 圖 3.2 展示了這整個是如何運作的。 這些旗標以及其他與頁面硬體有關的結構都定義在 [kernel/riscv.h](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/riscv.h) 中

若要讓 CPU 使用某個頁表，核心必須將根頁表的頁面的實體位址寫入 `satp` 暫存器中，這樣接下來 CPU 執行的所有指令所產生的位址，都會使用 `satp` 指向的頁表來進行轉換。 每顆 CPU 都有自己的 `satp` 暫存器，因此不同的 CPU 可以同時執行不同的行程，各自使用其私有的位址空間與頁表。 從核心的角度來看，頁表就是儲存在記憶體中的資料結構，核心會使用類似操作其他樹狀資料結構的方式來建立與修改頁表

這裡對書中所使用的一些術語做個簡要說明。 「實體記憶體」是指 RAM 中的儲存單元。 一個實體記憶體位元組會有一個稱為「實體位址」的位址。 那些會解參考位址的指令（例如 `load`、`store`、`jump`、function call）只會使用虛擬位址，這些虛擬位址會先由分頁硬體轉換為實體位址，再送到 RAM 進行讀寫

「位址空間」是指在某個頁表中有效的虛擬位址集合； xv6 中的每個行程都有自己的使用者位址空間，xv6 核心本身也有自己的位址空間。 「使用者記憶體」是行程的使用者位址空間加上頁表允許該行程存取的實體記憶體。 「虛擬記憶體」是一組與頁表管理有關的概念與技術，並透過它們來實現如隔離等目標

## Bibliography

- <a id="1">[1]</a>：The RISC-V instruction set manual Volume II: privileged specification. https://drive.google.com/file/d/1uviu1nH-tScFfgrovvFCrj7Omv8tFtkp/view?usp=drive_link, 2024
