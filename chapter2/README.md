# Chapter2：Operating system organization

作業系統的一項關鍵需求是要能夠同時支援多個活動，例如透過第一章所描述的系統呼叫介面，一個行程可以使用 `fork` 建立新的行程。 作業系統還必須在這些行程之間分時共享電腦的資源，例如即使行程數量超過了硬體 CPU 的數量，作業系統仍必須確保所有行程都能獲得執行的機會。 作業系統也必須在行程之間安排隔離機制，換句話說如果某個行程出現錯誤並發生故障，它不應該影響到那些不依賴它的行程。 然而，完全的隔離又過於強硬，因為行程之間應要可以有意地互動，例如管道（pipeline）就是一個例子。 因此，作業系統必須滿足三個需求：多工（multiplexing）、隔離（isolation）與互動（interaction）

本章將概述作業系統是如何組織架構，以實現這三項需求。 事實上，有許多不同的方式可以達成，但本書聚焦於以「整體式核心（monolithic kernel）」為中心的主流設計，這種設計被許多 Unix 作業系統所採用。 本章也會簡要說明 xv6 中的行程，它是 xv6 中實現隔離的基本單位，以及 xv6 啟動時建立第一個行程的過程

xv6 執行於一顆「多核心（multi-core）」的 RISC-V 微處理器上，其許多底層功能（例如行程的實作）都依賴於 RISC-V 架構。 RISC-V 是一種 64 位元的 CPU，而 xv6 是使用 "LP64" 模式的 C 語言撰寫的，這表示在 C 語言中，`long`（L）與指標（P）是 64 位元，而 `int` 則是 32 位元。 本書假設讀者已具備某些架構上機器層級（machine-level）的程式設計經驗，並會在需要時介紹與 RISC-V 有關的概念。 完整的 RISC-V 規格可以參考使用者層級 ISA 文件與特權層級架構文件。 你也可以參考《The RISC-V Reader: An Open Architecture Atlas》一書

在一台完整的電腦中，CPU 周圍會有許多輔助硬體，其中大部分以 I/O 介面的形式存在。 xv6 是針對 qemu 的 `-machine virt` 選項所模擬的這些輔助硬體所撰寫的。 這些硬體包括：RAM、一個包含開機程式的 ROM、一條與使用者鍵盤與螢幕相連的序列埠，以及一個用於儲存的硬碟

## 2.1 Abstracting physical resources

當人們第一次接觸作業系統時，可能會問的第一個問題是：為什麼需要作業系統？ 也就是說，可以將上一章的圖 1.2 中的系統呼叫全部實作成一個函式庫，應用程式只要連結該函式庫即可。 在這樣的設計下，每個應用程式甚至可以擁有一套量身打造的函式庫。 應用程式可以直接與硬體資源互動，並以最適合該應用的方式使用這些資源（例如，達成高效或可預期的效能）。 有些為嵌入式裝置或即時系統所設計的作業系統就是採用這種方式來組織的

這種函式庫式作法的缺點是，如果有多個應用程式同時執行，那麼這些應用程式必須都要是「行為良好（well-behaved）」的。 例如，每個應用程式都必須定期主動讓出 CPU，讓其他應用程式能夠執行。 這種「協作式（cooperative）」的分時機制，在所有應用程式彼此信任、而且沒有錯誤的情況下也許可以接受。 但在現實中，應用程式通常不會彼此信任，而且經常會有錯誤，因此我們常常需要比協作式更強的隔離機制

為了達成強隔離，禁止應用程式直接存取敏感的硬體資源，取而代之的將這些資源抽象成服務是有幫助的。 例如，Unix 應用程式與儲存裝置的互動只能透過檔案系統提供的 `open`、`read`、`write` 和 `close` 等系統呼叫，而不是直接對硬碟進行讀寫。 這不僅提供了路徑名稱的便利性，也讓作業系統作為該介面的實作者能夠管理硬碟。 即使隔離不是主要考量，有意互動的程式（或是只是想避免彼此干擾）也會發現檔案系統比直接使用硬碟來得更加方便

同樣地，Unix 能夠在不同的行程之間透明地切換硬體 CPU，並在需要時儲存與還原暫存器狀態，使得應用程式無需關心分時的細節。 這種透明性讓作業系統即使在有些應用程式陷入無窮迴圈的情況下，仍能實現 CPU 的共享

另一個例子是，Unix 的行程使用 `exec` 來建立它們的記憶體映像，而不是直接操作實體記憶體。 這樣一來，作業系統可以決定將行程放置在哪個記憶體位置； 如果記憶體不足，作業系統甚至可以把行程的一部分資料存放到硬碟上。 `exec` 也讓使用者能夠利用檔案系統來方便地儲存可執行的程式映像檔

Unix 行程之間的許多互動形式都是透過檔案描述符進行的。 檔案描述符不僅將許多細節（例如管道或檔案中的資料儲存位置）抽象化，且其設計方式也簡化了行程間的互動。 例如，如果管線中的某個應用程式失敗，核心會為下一個行程產生一個 end-of-file 訊號

圖 1.2 所示的系統呼叫介面經過了精心設計，以同時提供程式開發者的便利性與實現強隔離的可能性。 Unix 所採用的這種資源抽象方式並不是唯一的做法，但實踐證明它是一種有效的方法
