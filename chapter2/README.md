# Chapter2：Operating system organization

作業系統的一項關鍵需求是要能夠同時支援多個活動，例如透過第一章所描述的系統呼叫介面，一個行程可以使用 `fork` 建立新的行程。 作業系統還必須在這些行程之間分時共享電腦的資源，例如即使行程數量超過了硬體 CPU 的數量，作業系統仍必須確保所有行程都能獲得執行的機會。 作業系統也必須在行程之間安排隔離機制，換句話說如果某個行程出現錯誤並發生故障，它不應該影響到那些不依賴它的行程。 然而，完全的隔離又過於強硬，因為行程之間應要可以有意地互動，例如管道（pipeline）就是一個例子。 因此，作業系統必須滿足三個需求：多工（multiplexing）、隔離（isolation）與互動（interaction）

本章將概述作業系統是如何組織架構，以實現這三項需求。 事實上，有許多不同的方式可以達成，但本書聚焦於以「整體式核心（monolithic kernel）」為中心的主流設計，這種設計被許多 Unix 作業系統所採用。 本章也會簡要說明 xv6 中的行程，它是 xv6 中實現隔離的基本單位，以及 xv6 啟動時建立第一個行程的過程

xv6 執行於一顆「多核心（multi-core）」的 RISC-V 微處理器上，其許多底層功能（例如行程的實作）都依賴於 RISC-V 架構。 RISC-V 是一種 64 位元的 CPU，而 xv6 是使用 "LP64" 模式的 C 語言撰寫的，這表示在 C 語言中，`long`（L）與指標（P）是 64 位元，而 `int` 則是 32 位元。 本書假設讀者已具備某些架構上機器層級（machine-level）的程式設計經驗，並會在需要時介紹與 RISC-V 有關的概念。 完整的 RISC-V 規格可以參考使用者層級 ISA 文件與特權層級架構文件。 你也可以參考《The RISC-V Reader: An Open Architecture Atlas》一書

在一台完整的電腦中，CPU 周圍會有許多輔助硬體，其中大部分以 I/O 介面的形式存在。 xv6 是針對 qemu 的 `-machine virt` 選項所模擬的這些輔助硬體所撰寫的。 這些硬體包括：RAM、一個包含開機程式的 ROM、一條與使用者鍵盤與螢幕相連的序列埠，以及一個用於儲存的硬碟

## 2.1 Abstracting physical resources

當人們第一次接觸作業系統時，可能會問的第一個問題是：為什麼需要作業系統？ 也就是說，可以將上一章的圖 1.2 中的系統呼叫全部實作成一個函式庫，應用程式只要連結該函式庫即可。 在這樣的設計下，每個應用程式甚至可以擁有一套量身打造的函式庫。 應用程式可以直接與硬體資源互動，並以最適合該應用的方式使用這些資源（例如，達成高效或可預期的效能）。 有些為嵌入式裝置或即時系統所設計的作業系統就是採用這種方式來組織的

這種函式庫式作法的缺點是，如果有多個應用程式同時執行，那麼這些應用程式必須都要是「行為良好（well-behaved）」的。 例如，每個應用程式都必須定期主動讓出 CPU，讓其他應用程式能夠執行。 這種「協作式（cooperative）」的分時機制，在所有應用程式彼此信任、而且沒有錯誤的情況下也許可以接受。 但在現實中，應用程式通常不會彼此信任，而且經常會有錯誤，因此我們常常需要比協作式更強的隔離機制

為了達成強隔離，禁止應用程式直接存取敏感的硬體資源，取而代之的將這些資源抽象成服務是有幫助的。 例如，Unix 應用程式與儲存裝置的互動只能透過檔案系統提供的 `open`、`read`、`write` 和 `close` 等系統呼叫，而不是直接對硬碟進行讀寫。 這不僅提供了路徑名稱的便利性，也讓作業系統作為該介面的實作者能夠管理硬碟。 即使隔離不是主要考量，有意互動的程式（或是只是想避免彼此干擾）也會發現檔案系統比直接使用硬碟來得更加方便

同樣地，Unix 能夠在不同的行程之間透明地切換硬體 CPU，並在需要時儲存與還原暫存器狀態，使得應用程式無需關心分時的細節。 這種透明性讓作業系統即使在有些應用程式陷入無窮迴圈的情況下，仍能實現 CPU 的共享

另一個例子是，Unix 的行程使用 `exec` 來建立它們的記憶體映像，而不是直接操作實體記憶體。 這樣一來，作業系統可以決定將行程放置在哪個記憶體位置； 如果記憶體不足，作業系統甚至可以把行程的一部分資料存放到硬碟上。 `exec` 也讓使用者能夠利用檔案系統來方便地儲存可執行的程式映像檔

Unix 行程之間的許多互動形式都是透過檔案描述符進行的。 檔案描述符不僅將許多細節（例如管道或檔案中的資料儲存位置）抽象化，且其設計方式也簡化了行程間的互動。 例如，如果管線中的某個應用程式失敗，核心會為下一個行程產生一個 end-of-file 訊號

圖 1.2 所示的系統呼叫介面經過了精心設計，以同時提供程式開發者的便利性與實現強隔離的可能性。 Unix 所採用的這種資源抽象方式並不是唯一的做法，但實踐證明它是一種有效的方法

## 2.2 User mode, supervisor mode, and system calls

強隔離（strong isolation）需要在應用程式與作業系統之間設置一個嚴格的邊界。 如果某個應用程式出錯，我們不希望其會導致整個作業系統或其他應用程式也發生錯誤。 相反地，作業系統應該能夠清除這個失敗的應用程式，並繼續執行其他應用程式。 為了實現強隔離，作業系統使應用程式無法修改（甚至是讀取）作業系統的資料結構與指令，並且也無法存取其他行程的記憶體

CPU 提供了實現強隔離的硬體支援。 例如，RISC-V 擁有三種 CPU 執行指令的模式：machine mode（機器模式）、supervisor mode（監督者模式）、以及 user mode（使用者模式）。 在 machine mode 下執行的指令擁有完全的權限，CPU 啟動時會從 machine mode 開始。 machine mode 主要用於開機時對電腦進行初始化設定，xv6 只會在 machine mode 執行幾行程式碼，接著就會切換至 supervisor mode

在 supervisor mode 中，CPU 可以執行特權指令，例如啟用或關閉中斷、讀取與寫入頁表位址所儲存的暫存器等等。 如果某個處於 user mode 的應用程式試圖執行特權指令，CPU 不會執行該指令，而是會切換至 supervisor mode，讓 supervisor-mode 的程式碼能夠終止該應用程式，因為它做了不該做的事情。 第一章中的圖 1.1 說明了這種架構，應用程式只能執行 user-mode 的指令（例如加法等），稱為在 user space（使用者空間）中執行； 而 supervisor mode 的軟體則還能執行特權指令，稱為在 kernel space（核心空間）中執行。 執行於 kernel space（或 supervisor mode）的軟體被稱為核心（kernel）

應用程式無法直接呼叫核心函式，若其想要呼叫某個核心功能（例如 xv6 中的 `read` 系統呼叫），則必須轉移至核心。 CPU 提供了一條特殊的指令，用來將 CPU 從 user mode 切換到 supervisor mode，並從由核心指定的進入點進入核心（RISC-V 提供的 `ecall` 指令就是為此目的而設計的）。 一旦 CPU 切換到 supervisor mode，核心便能驗證該系統呼叫的參數（例如檢查傳入的記憶體位址是否屬於應用程式的範圍），決定應用程式是否有權執行該操作（例如檢查應用程式是否有權寫入指定檔案），然後決定是要拒絕還是執行該請求。 由核心控制切換到 supervisor mode 的進入點是非常重要的，如果應用程式能夠自行決定核心的進入點，惡意應用就可能從繞過參數驗證的位置進入核心

## 2.3 Kernel organization

一個關鍵的設計問題是：作業系統的哪些部分應該在 supervisor mode（監督者模式）下執行。 其中一種可能的做法是讓整個作業系統都駐留在核心中，這樣所有系統呼叫的實作都會在 supervisor mode 下執行，這種架構被稱為單體核心（monolithic kernel）

在這種架構中，整個作業系統是由一個在擁有完整硬體特權下執行的單一程式所構成。 這樣的設計相對方便，因為作業系統設計者不需要判斷作業系統中哪些部分不需要完整的硬體權限。 此外，作業系統的不同組件之間也會更容易合作，例如作業系統可能有一個緩衝區快取（buffer cache），可供檔案系統與虛擬記憶體系統共用

單體架構的缺點是：作業系統中不同部分的互動通常很複雜（如本書後續會提到），因此作業系統開發者很容易犯錯。 在單體核心中，錯誤通常是致命的，因為在 supervisor mode 發生錯誤往往會導致整個核心崩潰。 若核心失效，整台電腦就會停止運作，所有應用程式也都會失效，此時就必須重新啟動電腦

為了降低核心錯誤所帶來的風險，作業系統設計者可以儘量減少在 supervisor mode 下執行的作業系統程式碼，並將大部分作業系統的功能放在 user mode 執行，這種核心架構被稱為微核心（microkernel）

圖 2.1 說明了微核心的設計，在該圖中，檔案系統是一個以 user-level 執行的行程。 以行程形式執行的作業系統服務被稱為伺服器（servers）。 為了讓應用程式能夠與檔案伺服器互動，核心提供了一種「行程間通訊（inter-process communication）」機制，使得一個 user-mode 行程可以向另一個行程發送訊息。 例如，若像 shell 這樣的應用程式想讀寫一個檔案，它會傳送一個訊息給檔案伺服器並等待回覆

![（Figure 2.1: A microkernel with a file-system server）](image/mkernel.png)

在微核心架構中，核心介面只包含一些低層次的功能，例如啟動應用程式、傳送訊息、存取裝置硬體等。 這樣的設計使得核心本身能夠保持相對簡單，因為大部分的作業系統功能都由 user-level 的伺服器來負責

在現實世界中，單體核心與微核心這兩種架構都很流行。 許多 Unix 核心採用單體架構，例如 Linux 就是一個單體核心，但其中也有些作業系統功能是以 user-level 伺服器執行的（例如視窗系統）。 Linux 能為作業系統密集型的應用提供高效能環境，有部分就是因為核心子系統之間可以高度整合

像 Minix、L4 以及 QNX 等作業系統採用了微核心加伺服器的架構，並且在嵌入式環境中被廣泛使用。 L4 的一個變種「seL4」甚至小到足以被形式化驗證其記憶體安全性與其他安全特性<sup>[[1]](#1)</sup>。 作業系統開發者之間對於哪種架構較佳有許多爭論，目前也沒有哪一種架構優於另一種的明確證據。 此外，這也很取決於「較佳」的定義是什麼：更高的效能、更小的程式碼體積、更可靠的核心、更可靠的整體作業系統（包含使用者層服務）等等

實務上還有一些考量可能比架構選擇更重要。 有些作業系統採用微核心，但會將部分原本屬於 user-level 的服務放到 kernel space 中執行，以提高效能。 有些作業系統之所以維持單體核心，是因為它們最初就是這樣設計的，而將現有系統重寫成純微核心設計所需的代價太高，相較之下新增功能可能更值得投入

從本書的觀點來看，微核心與單體核心作業系統共享許多核心概念：它們實作系統呼叫、使用頁表、處理中斷、支援行程、使用鎖來控制並發、實作檔案系統等等。 本書將聚焦於這些核心概念

xv6 是以單體核心的方式實作的，與大多數 Unix 作業系統相同。 因此，xv6 的核心介面即對應作業系統的介面，且該核心實作了完整的作業系統。 雖然 xv6 並未提供太多服務，其核心的規模甚至比某些微核心還小，但在概念上，xv6 屬於單體核心

## Bibliography

- <a id="1">[1]</a>：Gerwin Klein, Kevin Elphinstone, Gernot Heiser, June Andronick, David Cock, Philip Derrin, Dhammika Elkaduwe, Kai Engelhardt, Rafal Kolanski, Michael Norrish, Thomas Sewell, Harvey Tuch, and Simon Winwood. Sel4: Formal verification of an OS kernel. In Proceedings of the ACM SIGOPS 22nd Symposium on Operating Systems Principles, page 207–220, 2009.
